task prepareLibSshirectories {
    mustRunAfter clean
    doLast {
        mkdir project.file("$project.protobuf_build/release")
        mkdir project.file("$project.protobuf_build/debug")
    }
}

// Runs the configure step.
def types = ["Debug", "Release"]
types.each { type ->
  project.tasks.create("configureProtobuf$type", Exec) {
    // Create an alias to the build directory.
    def build_dir = file("$protobuf_build/${type.toLowerCase()}")
    def install_dir = file("$protobuf_install/${type.toLowerCase()}")

    // LibSSH is configured with CMake. We want to build static libraries. Also set
    // the archive to be stored in build/lib instead of build/src (the default).
    executable "cmake"
    args "$protobuf_dir"

    if (project.platform == "osx-arm64") {
      args "-DCMAKE_OSX_ARCHITECTURES=arm64", "-DCMAKE_OSX_DEPLOYMENT_TARGET=\"11.0\""
      environment "ARCHFLAGS", "-arch arm64"
    } else if (project.platform == "osx-x86_64") {
      args "-DCMAKE_OSX_ARCHITECTURES=x86_64", "-DCMAKE_OSX_DEPLOYMENT_TARGET=\"10.15\""
      environment "ARCHFLAGS", "-arch x86_64"
    } else if (project.platform == "linux-arm64") {
      if (project.hasProperty('forcecrossbuild')) {
        args "-DCMAKE_TOOLCHAIN_FILE=$rootDir/cmake/aarch64-bullseye-gnu.toolchain.cmake"
      }
    } else if (project.platform == "linux-arm32") {
      if (project.hasProperty('forcecrossbuild')) {
       args "-DCMAKE_TOOLCHAIN_FILE=$rootDir/cmake/arm-pi-gnueabihf.toolchain.cmake"
      }
    } else if (project.platform == "linux-athena") {
      args "-DCMAKE_TOOLCHAIN_FILE=$rootDir/cmake/arm-frc-gnueabi.toolchain.cmake"
    }

    // CMAKE_INSTALL_CMAKEDIR needs a relative path (fixed in later protobuf releases
    def installRel_dir = relativePath(install_dir)

    args "-Dprotobuf_BUILD_SHARED_LIBS=ON", "-Dprotobuf_BUILD_TESTS=OFF",
        "-DCMAKE_ARCHIVE_OUTPUT_DIRECTORY=${build_dir}/lib", "-DCMAKE_BUILD_TYPE=$type",
        "-DCMAKE_INSTALL=${install_dir}",
        "-DCMAKE_INSTALL_PREFIX=${installRel_dir}",
        "-DCMAKE_INSTALL_CMAKEDIR=cmake",
        "-DCMAKE_INSTALL_INCLUDEDIR=${install_dir}/include",
        "-DCMAKE_INSTALL_LIBDIR=${install_dir}/lib",
        "-DCMAKE_INSTALL_BINDIR=${install_dir}/bin"
        //"-DCMAKE_POSITION_INDEPENDENT_CODE=ON"
    workingDir build_dir

    def platformArg = "x64"
    if (project.platform == "windows-x86") {
      platformArg = "Win32"
    } else if (project.platform == "windows-arm64") {
      platformArg = "arm64"
    }

    // Add the arch specifier for Windows.
    if (project.platform.contains("windows")) {
      args "-A"
      args platformArg
    }

    dependsOn prepareLibSshirectories
  }
}

// Runs the build step.
types.each { type ->
  project.tasks.create("buildProtobuf$type", Exec) {
    // Make sure that we are configured.
    dependsOn "configureProtobuf$type"

    // Create an alias to the build directory.
    def build_dir = file("$protobuf_build/${type.toLowerCase()}")

    // Use CMake to invoke the low-level build system.
    executable "cmake"
    args "--build", ".", "--parallel", "${project.processors}", "--target", "install"
    workingDir build_dir

    def platformArg = "/p:Platform=x64"
    if (project.platform == "windows-x86") {
      platformArg = "/p:Platform=win32"
    } else if (project.platform == "windows-arm64") {
      platformArg = "/p:Platform=arm64"
    }

    // Specify arch and build type on Windows.
    if (project.platform.contains("windows")) {
      args "--", "/p:Configuration=$type", "/v:m", platformArg
    }
  }
}

// Create a "mega-task" that builds everything.
types.each { type ->
  project.tasks.create("protobuf$type") {
    dependsOn "buildProtobuf$type"
  }
}
